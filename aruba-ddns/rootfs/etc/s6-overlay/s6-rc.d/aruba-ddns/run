#!/usr/bin/with-contenv bashio
# shellcheck shell=bash
set -euo pipefail

CERT_DIR=/data/letsencrypt
WORK_DIR=/data/workdir
LE_UPDATE="0"

API_BASE=""
API_KEY=""
USERNAME=""
PASSWORD=""
PASSWORD_BASE64="false"
DELEGATED_ENABLED="false"
DELEGATED_USERNAME=""
DELEGATED_PASSWORD=""
DELEGATED_FIRST_ACCESS_OTP=""
WAIT_TIME="300"
IPV4_CFG=""
IPV6_CFG=""
ALGO="secp384r1"
API_TOKEN=""

load_runtime_config() {
  API_BASE=$(bashio::config 'api_base')
  API_KEY=$(bashio::config 'api_key')
  USERNAME=$(bashio::config 'username')
  PASSWORD=$(bashio::config 'password')
  PASSWORD_BASE64=$(bashio::config 'password_base64')
  DELEGATED_ENABLED=$(bashio::config 'delegated_user.enabled')
  DELEGATED_USERNAME=$(bashio::config 'delegated_user.username')
  DELEGATED_PASSWORD=$(bashio::config 'delegated_user.password')
  DELEGATED_FIRST_ACCESS_OTP=$(bashio::config 'delegated_user.first_access_otp')
  WAIT_TIME=$(bashio::config 'seconds')
  IPV4_CFG=$(bashio::config 'ipv4')
  IPV6_CFG=$(bashio::config 'ipv6')
  ALGO=$(bashio::config 'lets_encrypt.algo')
}

urlencode() {
  jq -rn --arg v "$1" '$v|@uri'
}

to_api_type() {
  case "${1^^}" in
    A) echo "a" ;;
    AAAA) echo "aAAA" ;;
    *) return 1 ;;
  esac
}

resolve_ip() {
  local cfg="$1"
  if [[ -z "${cfg}" ]]; then
    echo ""
  elif [[ "${cfg}" == *"://"* ]]; then
    curl -fsSL -m 10 "${cfg}" | tr -d ' \t\r\n'
  else
    echo "${cfg}" | tr -d ' \t\r\n'
  fi
}

normalize_record_name() {
  local zone="$1"
  local name="$2"
  local z="${zone%.}"
  local n="${name%.}"

  if [[ -z "${n}" || "${n}" == "@" ]]; then
    echo "${z}"
  elif [[ "${n}" == *."${z}" ]]; then
    echo "${n}"
  else
    echo "${n}.${z}"
  fi
}

derive_zone_from_host() {
  local host="$1"
  local h="${host%.}"
  if [[ "${h}" != *.* ]]; then
    echo ""
    return 1
  fi
  echo "${h#*.}"
}


auth_token_for_user() {
  local auth_username="$1"
  local auth_password="$2"
  local auth_otp="$3"
  local body_file="$4"
  local err_file="$5"
  local password_for_auth payload code

  password_for_auth="${auth_password}"
  if [[ "${PASSWORD_BASE64}" == "true" ]]; then
    password_for_auth=$(printf '%s' "${auth_password}" | base64 | tr -d '\n')
  fi

  payload="grant_type=password&username=$(urlencode "${auth_username}")&password=$(urlencode "${password_for_auth}")"
  if [[ -n "${auth_otp}" ]]; then
    payload="${payload}&otp=$(urlencode "${auth_otp}")"
  fi

  code=$(curl -sS -o "${body_file}" -w "%{http_code}" -X POST "${API_BASE%/}/auth/token" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -H "Authorization-Key: ${API_KEY}" \
    --data "${payload}" 2>"${err_file}" || true)

  if [[ "${code}" != "200" ]]; then
    echo "HTTP ${code}; $(jq -r '.error_description // .error // .Message // .message // "auth failed"' "${body_file}" 2>/dev/null || cat "${err_file}")" >&2
    return 1
  fi

  jq -r '.access_token // empty' "${body_file}"
}

acquire_api_token() {
  local delegated_token primary_token
  local primary_err="/tmp/aruba_auth_primary_err.log"

  is_otp_required() {
    local file="$1"
    grep -Eqi 'one[- ]time password required|otp required|password monouso' "${file}" 2>/dev/null
  }

  if [[ "${DELEGATED_ENABLED}" != "true" ]]; then
    primary_token=$(auth_token_for_user "${USERNAME}" "${PASSWORD}" "" /tmp/aruba_auth_body.json /tmp/aruba_auth_curl_err.log 2>"${primary_err}" || true)
    if [[ -n "${primary_token}" ]]; then
      echo "${primary_token}"
      return 0
    fi

    if is_otp_required "${primary_err}" && [[ -n "${DELEGATED_FIRST_ACCESS_OTP}" ]]; then
      bashio::log.warning "OTP richiesto: uso first_access_otp per autenticazione utente principale"
      primary_token=$(auth_token_for_user "${USERNAME}" "${PASSWORD}" "${DELEGATED_FIRST_ACCESS_OTP}" /tmp/aruba_auth_primary_otp_body.json /tmp/aruba_auth_primary_otp_curl_err.log 2>/tmp/aruba_auth_primary_otp_err.log || true)
      if [[ -n "${primary_token}" ]]; then
        echo "${primary_token}"
        return 0
      fi
      cat /tmp/aruba_auth_primary_otp_err.log >&2
      return 1
    fi

    cat "${primary_err}" >&2
    return 1
  fi

  if [[ -z "${DELEGATED_USERNAME}" || -z "${DELEGATED_PASSWORD}" ]]; then
    bashio::log.warning "Delegated user abilitato ma credenziali incomplete; uso username/password principali"
    primary_token=$(auth_token_for_user "${USERNAME}" "${PASSWORD}" "" /tmp/aruba_auth_body.json /tmp/aruba_auth_curl_err.log 2>"${primary_err}" || true)
    if [[ -n "${primary_token}" ]]; then
      echo "${primary_token}"
      return 0
    fi

    if is_otp_required "${primary_err}" && [[ -n "${DELEGATED_FIRST_ACCESS_OTP}" ]]; then
      bashio::log.warning "OTP richiesto: uso first_access_otp per autenticazione utente principale"
      primary_token=$(auth_token_for_user "${USERNAME}" "${PASSWORD}" "${DELEGATED_FIRST_ACCESS_OTP}" /tmp/aruba_auth_primary_otp_body.json /tmp/aruba_auth_primary_otp_curl_err.log 2>/tmp/aruba_auth_primary_otp_err.log || true)
      if [[ -n "${primary_token}" ]]; then
        echo "${primary_token}"
        return 0
      fi
      cat /tmp/aruba_auth_primary_otp_err.log >&2
      return 1
    fi

    cat "${primary_err}" >&2
    return 1
  fi

  delegated_token=$(auth_token_for_user "${DELEGATED_USERNAME}" "${DELEGATED_PASSWORD}" "" /tmp/aruba_auth_delegated_body.json /tmp/aruba_auth_delegated_curl_err.log 2>/tmp/aruba_auth_delegated_err.log || true)
  if [[ -n "${delegated_token}" ]]; then
    bashio::log.info "Autenticazione API con delegated user ${DELEGATED_USERNAME}"
    echo "${delegated_token}"
    return 0
  fi

  if ! is_otp_required /tmp/aruba_auth_delegated_err.log; then
    cat /tmp/aruba_auth_delegated_err.log >&2
    return 1
  fi

  if [[ -z "${DELEGATED_FIRST_ACCESS_OTP}" ]]; then
    echo "HTTP 401; One-time password required per delegated user. Compila delegated_user.first_access_otp per bootstrap iniziale." >&2
    return 1
  fi

  bashio::log.warning "OTP richiesto sul delegated user: provo first_access_otp sul delegato"
  delegated_token=$(auth_token_for_user "${DELEGATED_USERNAME}" "${DELEGATED_PASSWORD}" "${DELEGATED_FIRST_ACCESS_OTP}" /tmp/aruba_auth_delegated_otp_body.json /tmp/aruba_auth_delegated_otp_curl_err.log 2>/tmp/aruba_auth_delegated_otp_err.log || true)
  if [[ -n "${delegated_token}" ]]; then
    ensure_delegated_user_no_otp "${delegated_token}" || true
    bashio::log.info "Bootstrap OTP completato con delegated user ${DELEGATED_USERNAME}"
    echo "${delegated_token}"
    return 0
  fi

  bashio::log.warning "OTP delegato non valido o non accettato: provo bootstrap con utente principale"
  primary_token=$(auth_token_for_user "${USERNAME}" "${PASSWORD}" "${DELEGATED_FIRST_ACCESS_OTP}" /tmp/aruba_auth_primary_otp_body.json /tmp/aruba_auth_primary_otp_curl_err.log 2>/tmp/aruba_auth_primary_otp_err.log || true)
  if [[ -z "${primary_token}" ]]; then
    cat /tmp/aruba_auth_primary_otp_err.log >&2
    return 1
  fi

  ensure_delegated_user_no_otp "${primary_token}" || true

  delegated_token=$(auth_token_for_user "${DELEGATED_USERNAME}" "${DELEGATED_PASSWORD}" "" /tmp/aruba_auth_delegated_retry_body.json /tmp/aruba_auth_delegated_retry_curl_err.log 2>/tmp/aruba_auth_delegated_retry_err.log || true)
  if [[ -z "${delegated_token}" ]]; then
    cat /tmp/aruba_auth_delegated_retry_err.log >&2
    return 1
  fi

  bashio::log.info "Bootstrap OTP completato: autenticazione ora su delegated user ${DELEGATED_USERNAME}"
  echo "${delegated_token}"
}

api_get_zone() {
  local token="$1"
  local zone="$2"
  local encoded_zone
  encoded_zone=$(urlencode "${zone}")

  curl -fsSL "${API_BASE%/}/api/domains/dns/${encoded_zone}/details" \
    -H "Authorization-Key: ${API_KEY}" \
    -H "Authorization: Bearer ${token}"
}

api_put_record() {
  local token="$1"
  local payload="$2"

  curl -fsSL -X PUT "${API_BASE%/}/api/domains/dns/record" \
    -H "Content-Type: application/json" \
    -H "Authorization-Key: ${API_KEY}" \
    -H "Authorization: Bearer ${token}" \
    --data "${payload}"
}

api_post_record() {
  local token="$1"
  local payload="$2"

  curl -fsSL -X POST "${API_BASE%/}/api/domains/dns/record" \
    -H "Content-Type: application/json" \
    -H "Authorization-Key: ${API_KEY}" \
    -H "Authorization: Bearer ${token}" \
    --data "${payload}"
}

api_get_delegated_user_detail() {
  local token="$1"
  local delegated_username="$2"
  local encoded_username code
  encoded_username=$(urlencode "${delegated_username}")

  code=$(curl -sS -o /tmp/aruba_delegate_detail_body.json -w "%{http_code}" \
    "${API_BASE%/}/api/delegatedusers/${encoded_username}/detail" \
    -H "Authorization-Key: ${API_KEY}" \
    -H "Authorization: Bearer ${token}" \
    2>/tmp/aruba_delegate_detail_err.log || true)

  echo "${code}"
}

api_disable_delegated_otp() {
  local token="$1"
  local payload="$2"
  local code

  code=$(curl -sS -o /tmp/aruba_delegate_otp_body.json -w "%{http_code}" -X PUT \
    "${API_BASE%/}/api/delegatedusers/OTP/Disactivate" \
    -H "Content-Type: application/json" \
    -H "Authorization-Key: ${API_KEY}" \
    -H "Authorization: Bearer ${token}" \
    --data "${payload}" \
    2>/tmp/aruba_delegate_otp_err.log || true)

  echo "${code}"
}

ensure_delegated_user_no_otp() {
  local token="$1"
  local delegated_enabled delegated_username
  local detail_code otp_code otp_payload otp_active body_message

  delegated_enabled=$(bashio::config 'delegated_user.enabled')
  if [[ "${delegated_enabled}" != "true" ]]; then
    return 0
  fi

  delegated_username=$(bashio::config 'delegated_user.username')

  if [[ -z "${delegated_username}" ]]; then
    bashio::log.warning "Delegated user abilitato ma username non configurato"
    return 0
  fi

  detail_code=$(api_get_delegated_user_detail "${token}" "${delegated_username}")
  if [[ "${detail_code}" == "200" ]]; then
    otp_active=$(jq -r '.ActiveOTP // empty' /tmp/aruba_delegate_detail_body.json 2>/dev/null || echo "")
  elif [[ "${detail_code}" == "404" ]]; then
    bashio::log.warning "Delegated user ${delegated_username} non trovato. Crealo nel pannello Aruba."
    return 0
  else
    body_message=$(jq -r '.Message // .message // .error_description // .error // empty' /tmp/aruba_delegate_detail_body.json 2>/dev/null || true)
    bashio::log.warning "Verifica delegated user fallita (${detail_code}): ${body_message:-$(cat /tmp/aruba_delegate_detail_err.log)}"
    return 0
  fi

  if [[ "${otp_active}" == "false" ]]; then
    bashio::log.info "Delegated user ${delegated_username}: OTP gia disattivato"
    return 0
  fi

  otp_payload=$(jq -nc --arg username "${delegated_username}" '{Username: $username}')
  otp_code=$(api_disable_delegated_otp "${token}" "${otp_payload}")

  if [[ "${otp_code}" == "200" ]]; then
    bashio::log.info "Delegated user ${delegated_username}: OTP disattivato"
  else
    body_message=$(jq -r '.Message // .message // .error_description // .error // empty' /tmp/aruba_delegate_otp_body.json 2>/dev/null || true)
    bashio::log.warning "Disattivazione OTP delegated user fallita (${otp_code}): ${body_message:-$(cat /tmp/aruba_delegate_otp_err.log)}"
  fi
}

le_renew() {
  local domain_args=()
  local domain

  while IFS= read -r domain; do
    [[ -z "${domain}" || "${domain}" == "null" ]] && continue
    domain_args+=("--domain" "${domain}")
  done < <(jq -r '.lets_encrypt.domains[]?' /data/options.json)

  if [[ "${#domain_args[@]}" -eq 0 ]]; then
    bashio::log.warning "Let's Encrypt attivo ma nessun dominio configurato in lets_encrypt.domains"
    LE_UPDATE="$(date +%s)"
    return 0
  fi

  bashio::log.info "Rinnovo certificati Let's Encrypt"
  dehydrated --cron --separate-challenges --algo "${ALGO}" \
    --hook /root/hooks.sh --challenge dns-01 \
    "${domain_args[@]}" --out "${CERT_DIR}" --config "${WORK_DIR}/config" || true

  LE_UPDATE="$(date +%s)"
}

update_records() {
  local token="$1"
  local current_ipv4="$2"
  local current_ipv6="$3"
  local total
  local auth_error=0
  declare -A seen_records=()

  total=$(jq '.records | length' /data/options.json)
  if [[ "${total}" -eq 0 ]]; then
    bashio::log.warning "Nessun record configurato"
    return 0
  fi

  for idx in $(seq 0 $((total - 1))); do
    local zone host name type create_if_missing content desired_content api_type api_type_code zone_data
    local zone_id full_name relative_name zone_lc existing existing_id existing_content payload
    local record_key

    zone=$(jq -r ".records[${idx}].zone // \"\"" /data/options.json)
    host=$(jq -r ".records[${idx}].host // \"\"" /data/options.json)
    name=$(jq -r ".records[${idx}].name // \"\"" /data/options.json)
    type=$(jq -r ".records[${idx}].type" /data/options.json)
    create_if_missing=$(jq -r ".records[${idx}].create_if_missing // true" /data/options.json)
    content=$(jq -r ".records[${idx}].content // \"\"" /data/options.json)

    if [[ -z "${type}" || ( -z "${host}" && -z "${name}" ) ]]; then
      bashio::log.warning "Record #${idx}: configurazione incompleta, salto"
      continue
    fi

    if [[ -n "${host}" ]]; then
      full_name="${host%.}"
      if [[ -z "${zone}" ]]; then
        zone="$(derive_zone_from_host "${full_name}" || true)"
      elif [[ "${zone}" != *.* ]]; then
        # Some UI saves can leave zone as a host label (e.g. zone=casa, host=brachini.com).
        # Auto-correct to full host "casa.brachini.com" and derive proper zone.
        full_name="${zone}.${full_name}"
        zone="$(derive_zone_from_host "${full_name}" || true)"
      fi
    else
      full_name=$(normalize_record_name "${zone}" "${name}")
    fi

    if [[ -z "${zone}" ]]; then
      bashio::log.warning "Record ${full_name}: zona DNS non determinabile (imposta zone o host valido)"
      continue
    fi

    if ! api_type=$(to_api_type "${type}"); then
      bashio::log.warning "Record ${full_name}: type non supportato (${type})"
      continue
    fi
    case "${api_type}" in
      a) api_type_code="0" ;;
      aAAA) api_type_code="1" ;;
      *) api_type_code="" ;;
    esac

    record_key="${full_name,,}|${api_type_code}"
    if [[ -n "${seen_records[${record_key}]:-}" ]]; then
      bashio::log.debug "SKIP duplicate config ${full_name} (${type})"
      continue
    fi
    seen_records["${record_key}"]=1

    if [[ -n "${content}" ]]; then
      desired_content="${content}"
    elif [[ "${type^^}" == "A" ]]; then
      desired_content="${current_ipv4}"
    else
      desired_content="${current_ipv6}"
    fi

    if [[ -z "${desired_content}" ]]; then
      bashio::log.warning "Record ${full_name} (${type}): contenuto vuoto, salto"
      continue
    fi

    if ! zone_data=$(api_get_zone "${token}" "${zone}" 2>/tmp/aruba_zone_err.log); then
      bashio::log.warning "Record ${full_name}: errore lettura zona ${zone}: $(cat /tmp/aruba_zone_err.log)"
      if grep -q "401" /tmp/aruba_zone_err.log; then
        auth_error=1
      fi
      continue
    fi

    zone_id=$(echo "${zone_data}" | jq -r '.Id // empty')
    if [[ -z "${zone_id}" ]]; then
      bashio::log.warning "Record ${full_name}: Id zona non trovato"
      continue
    fi

    relative_name="${full_name,,}"
    relative_name="${relative_name%.}"
    zone_lc="${zone,,}"
    zone_lc="${zone_lc%.}"
    if [[ "${relative_name}" == "${zone_lc}" ]]; then
      relative_name="@"
    elif [[ "${relative_name}" == *".${zone_lc}" ]]; then
      relative_name="${relative_name%.${zone_lc}}"
      relative_name="${relative_name%.}"
    fi

    existing=$(echo "${zone_data}" | jq -c \
      --arg n "${full_name,,}" \
      --arg nr "${relative_name}" \
      --arg t "${api_type,,}" \
      --arg tc "${api_type_code}" \
      '
      def norm: tostring | ascii_downcase | sub("\\.$";"");
      def rec_name: (.Name // .Host // .Record // "");
      def rec_type: (.Type // .RecordType // .DnsType // "");
      [.Records[]? | select(
        (((rec_name | norm) == ($n | norm)) or ((rec_name | norm) == ($nr | norm))) and
        (((rec_type | norm) == $t) or ((rec_type | norm) == $tc))
      )] | first // empty
      ')

    if [[ -n "${existing}" && "${existing}" != "null" ]]; then
      existing_id=$(echo "${existing}" | jq -r '.Id')
      existing_content=$(echo "${existing}" | jq -r '.Content // ""')

      if [[ "${existing_content}" == "${desired_content}" ]]; then
        bashio::log.debug "NOCHANGE ${full_name} (${type}) -> ${desired_content}"
        continue
      fi

      payload=$(jq -nc \
        --argjson id "${existing_id}" \
        --arg name "${full_name}" \
        --arg content "${desired_content}" \
        '{IdRecord: $id, Name: $name, Content: $content}')

      if api_put_record "${token}" "${payload}" >/tmp/aruba_put_ok.log 2>/tmp/aruba_put_err.log; then
        bashio::log.info "UPDATED ${full_name} (${type}) -> ${desired_content}"
      else
        bashio::log.warning "Errore update ${full_name}: $(cat /tmp/aruba_put_err.log)"
      fi
      continue
    fi

    if [[ "${create_if_missing}" != "true" ]]; then
      bashio::log.warning "Record ${full_name} non trovato e create_if_missing=false"
      continue
    fi

    payload=$(jq -nc \
      --argjson idDomain "${zone_id}" \
      --arg typeVal "${api_type}" \
      --arg name "${full_name}" \
      --arg content "${desired_content}" \
      '{IdDomain: $idDomain, Type: $typeVal, Name: $name, Content: $content}')

    if api_post_record "${token}" "${payload}" >/tmp/aruba_post_ok.log 2>/tmp/aruba_post_err.log; then
      bashio::log.info "CREATED ${full_name} (${type}) -> ${desired_content}"
    else
      bashio::log.warning "Errore create ${full_name}: $(cat /tmp/aruba_post_err.log)"
    fi
  done

  if [[ "${auth_error}" -eq 1 ]]; then
    return 2
  fi
}

load_runtime_config

if bashio::config.true 'lets_encrypt.accept_terms'; then
  mkdir -p "${CERT_DIR}" "${WORK_DIR}"

  if [[ -e "${WORK_DIR}/lock" ]]; then
    rm -f "${WORK_DIR}/lock"
    bashio::log.warning "Reset dehydrated lock file"
  fi

  if [[ ! -f "${WORK_DIR}/config" ]]; then
    touch "${WORK_DIR}/config"
  fi

  if [[ ! -d "${CERT_DIR}/accounts" ]]; then
    dehydrated --register --accept-terms --config "${WORK_DIR}/config" || true
  fi
fi

bashio::log.info "Starting Aruba DDNS"
while true; do
  load_runtime_config

  if [[ -z "${API_TOKEN}" ]]; then
    API_TOKEN=$(acquire_api_token 2>/tmp/aruba_auth_err.log || true)

    if [[ -z "${API_TOKEN}" ]]; then
      bashio::log.error "Autenticazione Aruba fallita: $(cat /tmp/aruba_auth_err.log)"
      sleep "${WAIT_TIME}"
      continue
    fi
  fi

  ipv4=$(resolve_ip "${IPV4_CFG}")
  ipv6=$(resolve_ip "${IPV6_CFG}")

  if [[ -z "${ipv4}" ]]; then
    ipv4=$(curl -fsSL -m 10 https://api.ipify.org || true)
  fi

  if [[ -n "${IPV6_CFG}" && -z "${ipv6}" ]]; then
    ipv6=$(curl -fsSL -m 10 https://api6.ipify.org || true)
  fi

  rc=0
  update_records "${API_TOKEN}" "${ipv4}" "${ipv6}" || rc=$?
  if [[ "${rc}" -eq 2 ]]; then
    bashio::log.warning "Token Aruba non valido/scaduto; nuovo login richiesto al prossimo ciclo"
    API_TOKEN=""
  fi

  now="$(date +%s)"
  if bashio::config.true 'lets_encrypt.accept_terms' && [[ $((now - LE_UPDATE)) -ge 43200 ]]; then
    le_renew
  fi

  sleep "${WAIT_TIME}"
done
